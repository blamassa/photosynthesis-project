import json
import requests as rq
import pandas as pd

def retrieve_fct(params:tuple):
    ''' Formats the met.no weather api 2.0 url with the coordinates (lat, lon and alt) and retrieves
     the api connection.

    Args:
        params (tuple): Tuple containing (lat, lon, altitude)

    Returns:
        The api connection response object
    '''
    headers = {'User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'}    
    url = 'https://api.met.no/weatherapi/locationforecast/2.0/complete?lat={}&lon={}&altitude={}'
    
    # Insert params in the url
    r_url = url.format(*params.values())
    # Request connect
    r = rq.get(r_url, headers = headers)
    return r
    
def save_json(r, filename:str):
    ''' Writes the JSON file with forecasts (RAW).

    Args:
        r (object): requests.models.Response, The api connection response object, returned by retrieve_fct().
        filename (str): name of the json forecast file to be saved, generally "place.json".
    '''
    # Read forecast as json
    data = r.json()
    # Writes forecast as Json
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)


def open_json_file(filename:str):
    ''' Reads and returns a JSON file.
    
    Args:
        filename (str): name of the json forecast file to be read, generally "place.json".

    Returns:
        data (dict): parsed JSON file in as a dict object.
    '''
    with open(filename) as json_file:
        data = json.load(json_file)
    return data

def create_df_from_JSON(data_file):
    ''' Selects relevant information ['air_temperature', 'cloud_area_fraction', 'relative_humidity']
        from JSON and returns a pandas dataframe.
        
    Args:
        data_file (dict): parsed JSON file in as a dict object. In it there are the forecasts of an specific location.
    
    Returns:
        df (pandas.DataFrame): DF with the columns ['date', 'time', 'air_temperature', 'cloud_area_fraction',
       'relative_humidity']
    '''
    
    # Generate a list of timepoints
    timepoints = data_file['properties']['timeseries']
    
    # Create a pandas df with instant timepoints
    keys = ['air_temperature', 'cloud_area_fraction', 'relative_humidity']

    df = pd.DataFrame(columns=['date','time']+keys)

    # Iterate through timepoints in order to retrieve details
    for tpt in timepoints:
        # Format datetime
        datetime = tpt['time'].replace('Z','').split('T')
        # Create list of datetime and details (air temperature, cloud area fraction and relative humidity)
        details = [tpt['data']['instant']['details'][i] for i in keys]
        data = [datetime + list(details)]

        # Try to append the timepoint to the dataframe, otherwise print the error
        try:
            df_tmp = pd.DataFrame(data = data,columns=['date','time']+keys)
            #df = df.append(df_tmp)
            df = pd.concat([df,df_tmp])
        except:
            print(datetime[0], end = '... FAIL')
            print(details)
    return df

def clean_data(df):
    ''' Runs the data cleaning processes: selects only 6 hours intervals, resets index and creates weekday column.
    
    Args:
        df (pandas.DataFrame): DF generated by the create_df_from_JSON function, with the columns ['date', 'time', 'air_temperature', 'cloud_area_fraction',
       'relative_humidity'].

    Returns:
        df_index (pandas.DataFrame): DF with the data cleaning process run.
    '''
    # Select only 6hrs intervals
    df_6hr = df[df['time'].isin(['00:00:00','06:00:00','12:00:00','18:00:00'])]
    # Reset index
    df_index = df_6hr.reset_index(drop = True)
    # Create weekday column where 0 is Monday
    df_index['date'] = pd.to_datetime(df_index['date'])
    df_index['weekday'] = df_index['date'].dt.weekday # 0 is Monday

    return df_index